package com.github.aoc

import scala.collection.mutable.ListBuffer
import scala.collection.mutable.HashSet

object Day21 {
  
  val ex = """../.# => ##./#../...
.#./..#/### => #..#/..../..../#..#"""
  
  val data = """../.. => .##/##./.#.
#./.. => .#./#.#/##.
##/.. => #.#/#.#/###
.#/#. => #../.#./.#.
##/#. => ##./#.#/..#
##/## => #.#/#.#/...
.../.../... => ..##/##../##../#.#.
#../.../... => ##.#/..#./#.#./.#..
.#./.../... => ..#./##.#/#.##/###.
##./.../... => ###./##.#/.###/#.#.
#.#/.../... => ##../#..#/.###/#.#.
###/.../... => ...#/#..#/...#/...#
.#./#../... => ...#/.##./#.##/..#.
##./#../... => .##./.#../.##./.#..
..#/#../... => ####/.#../#.#./.###
#.#/#../... => ###./.#../##../....
.##/#../... => ##../#.#./#.#./##..
###/#../... => #.##/#..#/.#../##..
.../.#./... => .#.#/.###/.##./##..
#../.#./... => .###/.##./..##/..##
.#./.#./... => .##./.#.#/#.##/.###
##./.#./... => ..#./..../..#./###.
#.#/.#./... => ..../..#./..##/##..
###/.#./... => .#.#/#..#/.###/#..#
.#./##./... => ..../..#./.#../####
##./##./... => ..##/#.##/..#./#.##
..#/##./... => ..../#.##/.##./####
#.#/##./... => ..##/#.#./.#../.##.
.##/##./... => #.../...#/###./....
###/##./... => .#../#.#./#.##/....
.../#.#/... => #.#./####/#.../..#.
#../#.#/... => ...#/.#.#/###./.#.#
.#./#.#/... => #..#/#.../###./#.##
##./#.#/... => .##./#.../...#/#.##
#.#/#.#/... => #..#/##../##../.#..
###/#.#/... => #.#./...#/.#.#/.##.
.../###/... => .#.#/.##./..#./.#..
#../###/... => .###/..##/#.##/.#..
.#./###/... => #.../#.../.#../#...
##./###/... => .###/...#/.#.#/.#..
#.#/###/... => .#../..##/#..#/#...
###/###/... => .###/##../##.#/#.#.
..#/.../#.. => ##.#/..../...#/..##
#.#/.../#.. => .#.#/###./...#/.#.#
.##/.../#.. => ##.#/.#../####/#.##
###/.../#.. => #.../#..#/###./....
.##/#../#.. => #..#/..#./####/...#
###/#../#.. => ####/###./##.#/....
..#/.#./#.. => .##./.##./##../#..#
#.#/.#./#.. => #..#/#..#/#.../.#..
.##/.#./#.. => ##../##.#/#.##/..##
###/.#./#.. => #.##/..##/.##./#.#.
.##/##./#.. => #.##/..../##../....
###/##./#.. => ###./.#.#/.###/.#..
#../..#/#.. => .###/#.##/..#./.##.
.#./..#/#.. => #..#/..##/.#.#/##..
##./..#/#.. => ###./#.../..##/##..
#.#/..#/#.. => #.../.##./.###/###.
.##/..#/#.. => ...#/##.#/..#./...#
###/..#/#.. => ###./..#./.#../...#
#../#.#/#.. => #..#/...#/..#./.#.#
.#./#.#/#.. => #..#/##.#/####/.##.
##./#.#/#.. => .###/##../..../.#..
..#/#.#/#.. => ..#./##.#/####/###.
#.#/#.#/#.. => #.#./#.##/##.#/.###
.##/#.#/#.. => ..#./####/##../.###
###/#.#/#.. => .#.#/###./.#.#/#...
#../.##/#.. => .###/..##/.#.#/..#.
.#./.##/#.. => #.##/.#../.###/#.#.
##./.##/#.. => .###/#.../#.../..#.
#.#/.##/#.. => ##../...#/..#./...#
.##/.##/#.. => ..##/.#.#/...#/####
###/.##/#.. => ##../.###/##../###.
#../###/#.. => ###./#..#/#.#./....
.#./###/#.. => ..../#.#./.###/.###
##./###/#.. => .###/##../#..#/####
..#/###/#.. => ..../#.#./#..#/##..
#.#/###/#.. => .#.#/..##/##.#/#..#
.##/###/#.. => .#../...#/##../.#..
###/###/#.. => #.../.###/###./##.#
.#./#.#/.#. => .#.#/#.##/###./#...
##./#.#/.#. => .#../.#../.#../.#..
#.#/#.#/.#. => ##.#/..../###./.#..
###/#.#/.#. => #.#./##.#/.#.#/##..
.#./###/.#. => ##.#/..#./..#./#.#.
##./###/.#. => ####/.###/.#.#/.##.
#.#/###/.#. => .#../.###/##../#.#.
###/###/.#. => #.../.##./..##/####
#.#/..#/##. => ..../..#./##../...#
###/..#/##. => .###/..#./#.##/###.
.##/#.#/##. => .###/..../#.#./...#
###/#.#/##. => ###./...#/.###/####
#.#/.##/##. => #.##/#.../..../...#
###/.##/##. => #.../#.../#..#/...#
.##/###/##. => .#../###./.###/..#.
###/###/##. => ##.#/.#../###./.#..
#.#/.../#.# => #.#./#.#./..../...#
###/.../#.# => ####/###./..../##.#
###/#../#.# => .###/##.#/#.##/..#.
#.#/.#./#.# => ###./.###/#.##/....
###/.#./#.# => .##./###./#.#./##..
###/##./#.# => #.../.#.#/#.##/#..#
#.#/#.#/#.# => ..#./#.#./##../..##
###/#.#/#.# => ..#./.#../...#/.##.
#.#/###/#.# => ..#./###./##.#/####
###/###/#.# => #.../#.#./#..#/.#.#
###/#.#/### => ..##/.##./.#.#/#...
###/###/### => .##./..##/####/###."""
  
  val input = ".#./..#/###"
  val input2 = "#..#/..../..../#..#"
  
  case class Rule( val size : Int, val pattern : String, val output : String, val combos : List[String] )
  
  def main( args : Array[String] ) : Unit = {
    Console.println( "day 21 start" )
    
    val lines = Common.toLines( data )
    
    val rules = lines.map( toRule( _ ) )
    // rules.foreach( Console.println( _ ) )
    
    var is = input2.split("/").toList 
    var size = is(0).size 
    
    printGrid(is)
    
    if( size % 2 == 0 ){
      Console.println( "2s" )
    }
    else if( size % 3 == 0 ) {
      Console.println( "3s" )
    }
    else {
      Console.println( "nope" )
    }
    
    val result = toGrid( is ) 
    printGrid( result )
    
    Console.println( "day 21 done" )
  }
  
  def printGrid( lines : List[String] ) : Unit = {
    lines.foreach( Console.println( _ ) )
  }
  
  def printGrid( g : Array[Array[Char]] ) : Unit = {
    val sz = g(0).size
    for( y <- 0 until sz ){
      for( x <- 0 until sz ){
        Console.print( g(y)(x) )
      }
      Console.print( "\n" )
    }
  }

  def toGrid( lines : List[String] ) : Array[Array[Char]] = {
    
    val sz = lines(0).size
    val output = Array.ofDim[Char](sz,sz) 
    
    for( y <- 0 until sz ){
      for( x <- 0 until sz ){
        output(y)(x) = lines(y)(x)
      }
    }
    
    output
    
  }
  
  def toRule( line : String ) : Rule = {
    
    val p1 = line.split("=>")
    
    val pat = p1(0).trim()
    val out = p1(1).trim()
    
    val sp = p1(0).trim().split("/")
    val sz = sp(0).size
    
    // make all the combos
    val cs = makeCombos( sp.toList )
    
    Rule( sz, pat, out, cs ) 
    
  }
  
  def hFlip( in : List[String] ) : List[String] = {
    
    val out = ListBuffer[String]()
    
    for( s <- in ){
      out += s.reverse
    }
    
    out.toList
    
  }
  
  def rotate( in : List[String] ) : List[String] = {
    
    val out = ListBuffer[String]()
    
    // get the size
    val sz = in(0).size
    
    for( x <- 0 until sz ){
      var s = ""
      for( y <- sz - 1 to 0 by -1 ){
        s = s + in(y)(x)
        
      }
      out += s
    }
    
    out.toList
    
  }
  
  def vFlip( in : List[String] ) : List[String] = {
    in.reverse
  }
  
  
  
  def isMatch( a : List[String], b : List[String] ) : Boolean = {
    val z = a.zip(b)
    z.forall( ( t : (String,String) ) => { t._1.equals(t._2) } ) 
  }
  
  def testSame() : Unit = {
    val a = List( ".#.", "..#", "###" )
    val b = List( ".#.", "..#", "###" )
    Console.println( isMatch( a, b ) )
  }
  
  def combine( a : List[String] ) : String = {
    a.mkString("/")
  }
  
  def makeCombos( a : List[String] ) : List[String] = {

    val all = HashSet[String]()
    
    var r = a
    for( i <- 0 until 4 ){
      r = rotate(r)
      all += combine(r)
    }

    var h = hFlip(a)
    for( i <- 0 until 4 ){
      h = rotate(h)
      all += combine(h)
    }
    
    
    var v = hFlip(a)
    for( i <- 0 until 4 ){
      v = rotate(v)
      all += combine(v)
    }
    
    all.toList
    
  }

  def testCombos() : Unit = {
    val a = List( ".#.", "..#", "###" )
    Console.println( makeCombos(a) )
  }
  /*
    
.#.   .#.   #..   ###
..#   #..   #.#   ..#
###   ###   ##.   .#.

.##
#.#
..#
 
*/
  
  
}